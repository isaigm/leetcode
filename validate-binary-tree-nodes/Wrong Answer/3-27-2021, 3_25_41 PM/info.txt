{"id":473169319,"lang":"cpp","lang_name":"C++","time":"1 year, 9 months","timestamp":1616880341,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/473169319/","is_pending":"Not Pending","title":"Validate Binary Tree Nodes","memory":"N/A","code":"class Solution {\npublic:\n  void dfs(unordered_set<int>& visited, int& curr_node, vector<int>& leftChild, vector<int>& rightChild) {\n        if (visited.find(curr_node) != visited.end() || curr_node == -1) return;\n        \n        visited.insert(curr_node);\n        dfs(visited, leftChild[curr_node], leftChild, rightChild);\n        dfs(visited, rightChild[curr_node], leftChild, rightChild);                    \n    }\n    \n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\n        // to dos\n        // 1. find node that has not appeared from 0 to n-1, which will be the root\n        // 2. dfs start from root, keep track of visited nodes\n        // 3. if all nodes can be visited, return true, else false\n        // time: o(n)\n        // space: o(n)\n        \n        unordered_set<int> find_root;\n        for (int i = 0; i < n; i++) {\n            find_root.insert(i);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (leftChild[i] != -1) {\n                find_root.erase(leftChild[i]);\n            }\n            if (rightChild[i] != -1) {\n                find_root.erase(rightChild[i]);\n            }\n        }\n        \n        if (find_root.size() != 1) {            \n            return false;\n        }\n        \n        int root = *find_root.begin();\n        \n        unordered_set<int> visited;\n        \n        dfs(visited, root, leftChild, rightChild);\n        \n        return visited.size() == n;                            \n    }\n};","compare_result":"10111111110111011111111111111111111111111","title_slug":"validate-binary-tree-nodes","has_notes":false,"notes":"","topic_tags":[]}